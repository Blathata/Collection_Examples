import re

# re.findall - возвращает список найденых вхождений
# re.search(pattern, string, flags) - поиск первого вхождения
# re.finditer(patter, string, flags) - возвращает итерируемые обьекты цикл внизу
#      -for match in re.search(r"(?P<key>\w+)=(?P<value>#[\da-fA-F]{6})\b", text)
# re.match(pattern, string, flags) определяет шаблон pattern в начале строки string
# re.split(r'[\n;,]') - метод разбивает текст по разделителю
# re.sub(pattern, repl, string, count, flags) замена совпадений в string, на repl
#
# Специальные символы \.^$?+*{}[]()|
# \n - символ перевода строки
# \t - смвол табуляции
# [] - символьный класс
# r ' ' - регулярное выражение
# [^:] - все слова кроме точки с запятой
# {2, 5}? - ленивый, минорный, знак вопроса после
# * {0,} - одно и тоже
# + {1,} - одно и тоже
# \w - символ слово
# \s - пробельный символ
# r"<img[^>]*>" - доходит до угловой скоби и останавливается 
# | - или

# ЖАДНЫЕ КВАНТИФИКАТОРЫ
# {m,n} - от m до n
# {,n} - до n
# {m,} - от m
# * - от 0
# +- от 1
# ? - от 0 до 1

# ЛЕНИВЫЕ КВАНТИФИКАТОРЫ
# {m,n}? - от m до n
# {,n}? - до n
# {m,}? - от m
# *? - от 0
# +? - от 1
# ?? - от 0 до 1

# \n	Новая строка
# .	    Любой символ, кроме символа новой строки. Если flags=re.DOTALL - любой символ.
# \s	Любой символ пробела, табуляции или новой строки.
# \S	Любой символ, кроме пробела, табуляции или новой строки.
# \d	Любая цифра. Ищет все цифры: арабские, персидские, индийские, и так далее. Не эквивалентен [0-9]
# \D	Любой символ, кроме цифр.
# \w	Любая буква, цифра, или _. Шаблон не соответствует выражению [a-zA-Z0-9_]! Буквы используются не только латинские, туда входит множество языков.
# \W	Любой символ, кроме букв, цифр, и _.
# \b	Промежуток между символом, совпадающим с \w и символом, не совпадающим с \w в любом порядке.
# \B	Промежуток между двумя символами, совпадающими с \w или \W.
# \A	Начало всего текста
# \Z	Конец всего текста
# ^	Начало всего текста или начало строчки текста, если flags=re.MULTILINE
# $	Конец всего текста или конец строчки текста, если flags=re.MULTILINE


# re.findall r"(lat|lon)\s*=\s*(\d+)" = [('lat', '5'), ('lon', '7')]
# re.findall r"(?:lat|lon)\s*=\s*\d+" = ['lat = 5', 'lon = 7'] 
#  ?: - групирующая скобка является несохраняющей если добавлен ?:
# re.findall r"(lat|lon)\s*=\s*\d+" = ['lat', 'lon'] групирующая скобка является сохраняющей, ключи
# re.findall r"<script[^>]*>"
# [^>]* - все символы кроме >
# re.findall(r"(lat|lon)\s*=\s*(\d+)"  [('lat', '5'), ('lon', '7')] - сохраняет в кортеж
# re.findall r"\s*=\s*\d+([\'"])(.+?)\1" ** \1 вызывает 1-е сохраняющие скобки т.е ([\'"]) 
# обращаемся вместо индекса по имени (?P<name>) -> (?P=name) пример: (?P<q>[\'"]) -> (?P=q) 

#  ФЛАГИ re.MULTILINE и ПРОВЕРКИ 

# re.findall(r"\b(прибыль|обретение|доход)\b - граница слова \b пименяется ко всем
# re.findall(r "^script 123, text, re.MULTILINE"  ФЛАГ re.MULTILINE означает что тес начинается со строки 'script'
# re.findall(r"(?=</script>)" -  опережающая проверка, не входит в шаблон. (?<=</script>) - входит в ответ ретроспективная

#Шаблон если найдена или ненайдена группа, если исползуем группирующие выражнения (?P<q>[\''])
# (?(id|name)yes_pattern) если найдена. (?(id|name)yes_pattern|no_pattern - найдена или ненайдена)


#СКОБОЧНЫЕ ВЫРАЖЕНИЯ

#regex = r'(?<=\[\^START\]).*(?=\{\(END\.\)\})' - ищем между 

# x(?=y) находит x, только если за x следует y
# x(?!y) находит x, только если за x НЕ следует y
# (?<=y)x находит x, только если перед x следует y
# (?<!y)x находит x, только если перед x НЕ следует y


text = 'подоходный налог, доход'
match = re.findall(r"\b(прибыль|обретение|доход)\b", text)

# print(match)

text = '<font color=#CC0000>'
match2 = re.search(r"(\w+)=(#[\da-fA-F]{6})\b", text)

print(match2.group(0, 1, 2)) #показывает группы
print(match2.lastindex) #определяет сколько групп содержится
print(match2.start(1)) # с какого индекса начинается группа
print(match2.end(1)) # заканчивается индекса группа
print(match2.span(0)) #начальная и конечная
print(match2.re) # возвращает скомпелированый шаблон

text = '<font color=#CC0000>'
match3 = re.search(r"(?P<key>\w+)=(?P<value>#[\da-fA-F]{6})\b", text)
print(match3.groupdict()) # возвращает {'key': 'color', 'value': '#CC0000'}
print(match3.expand(r'\g<key>:\g<value>')) # возвращает color:#CC0000
print(match3.expand(r'\1:\2')) # возвращает color:#CC0000


text = '<font color=#CC0000=123=888>'
match4 = re.split(r"[=]+", text)
print(match4)
